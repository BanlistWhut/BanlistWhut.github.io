(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{399:function(a,t,e){"use strict";e.r(t);var s=e(27),v=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[a._v("#")]),a._v(" 概念")]),a._v(" "),e("p",[a._v("在生产环境中使用 Docker，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享。\n容器中的数据管理方式有两种：")]),a._v(" "),e("ol",[e("li",[a._v("数据卷（Data Volumes）：容器内数据直接映射到本地主机环境")]),a._v(" "),e("li",[a._v("数据卷容器（Data Volumes Containers）：使用特定容器维护数据卷")])]),a._v(" "),e("h2",{attrs:{id:"数据卷"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据卷"}},[a._v("#")]),a._v(" 数据卷")]),a._v(" "),e("p",[a._v("数据卷是一个可供容器使用的特殊目录，它将主机目录直接映射进容器，类似于 Linux 中的 mount 行为。\n数据卷提供了一些特性：")]),a._v(" "),e("ol",[e("li",[a._v("数据卷可以在容器之间共享和重用，容器间传递数据将变得高效与方便")]),a._v(" "),e("li",[a._v("对数据卷内数据的修改会立即生效，无论容器内操作还是主机操作")]),a._v(" "),e("li",[a._v("对数据卷的更新不会影响镜像，解耦开应用和数据")]),a._v(" "),e("li",[a._v("卷会一直存在，知道没有容器使用，可以安全地卸载它")])]),a._v(" "),e("h3",{attrs:{id:"_1-操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-操作"}},[a._v("#")]),a._v(" 1. 操作")]),a._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 创建")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# docker volume create [OPTIONS] [VOLUME]")]),a._v("\ndocker volume create hello\n")])])]),e("p",[a._v("根据 "),e("code",[a._v("docker inspect hello")]),a._v(" 可得知数据卷数据存放在 "),e("code",[a._v("/var/lib/docker/volumes/")]),a._v(" 下。")]),a._v(" "),e("h2",{attrs:{id:"数据卷容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据卷容器"}},[a._v("#")]),a._v(" 数据卷容器")]),a._v(" "),e("p",[a._v("数据卷容器也是一个容器，但它的目的是专门提供数据卷给其他容器挂载。")]),a._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 创建数据卷容器")]),a._v("\ndocker run -it -v /dbdata --name dbdata ubuntu\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 接着可以在其他容器中挂载数据卷")]),a._v("\ndocker run -it --volumes-from dbdata --name db1 ubuntu\ndocker run -it --volumes-from dbdata --name db2 ubuntu\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 个人认为该形式并不好")]),a._v("\n")])])]),e("p",[a._v("注意 "),e("code",[a._v("dbdata")]),a._v(" 容器中使用了 "),e("code",[a._v("-v")]),a._v("，但其后仅跟随了 "),e("code",[a._v("/dbdata")]),a._v("，实际上会生成一个匿名的 volume，根据这个也可以推导出若跟随参数为 "),e("code",[a._v("hello/dbdata")]),a._v(" 则会创建一个 "),e("code",[a._v("hello")]),a._v(" volume，跳过先创建数据卷的步骤。")]),a._v(" "),e("p",[a._v("更进一步我们可以推导出 "),e("code",[a._v("-v")]),a._v(" 无法指定去掉 "),e("code",[a._v("./")]),a._v(" 的相对路径。")])])}),[],!1,null,null,null);t.default=v.exports}}]);